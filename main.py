# moex_stock_bot.py

import matplotlib
matplotlib.use('Agg')  # –í–∫–ª—é—á–∞–µ–º "–±–µ–∑–≥–æ–ª–æ–≤—ã–π" —Ä–µ–∂–∏–º –¥–ª—è matplotlib
import requests
import pandas as pd
import numpy as np
import os  # ‚Üê –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞ —Å–∞–º–æ–º –≤–µ—Ä—Ö—É, –Ω–∞ —É—Ä–æ–≤–Ω–µ –¥—Ä—É–≥–∏—Ö –∏–º–ø–æ—Ä—Ç–æ–≤
import matplotlib.pyplot as plt
from datetime import datetime
from scipy.signal import argrelextrema
import asyncio

# –ó–∞–º–µ–Ω—è–µ–º telegram –Ω–∞ —É—Å–ª–æ–≤–Ω—ã–π –∑–∞–≥–ª—É—à–∫—É –∏–ª–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–∫–∏ –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏
try:
    from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
    from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, ContextTypes
except ModuleNotFoundError:
    print("–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ 'python-telegram-bot' –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.")
    Update = None
    ApplicationBuilder = None
    CommandHandler = None
    CallbackQueryHandler = None
    ContextTypes = None

SECTORS = {
    "–§–∏–Ω–∞–Ω—Å—ã": ["SBER", "T", "VTBR", "MOEX", "SPBE", "RENI", "BSPB", "SVCB", "MBNK", "LEAS", "SFIN", "AFKS", "CARM", "ZAYM", "CBOM"],
    "–ù–µ—Ñ—Ç–µ–≥–∞–∑": ["GAZP", "NVTK", "LKOH", "ROSN", "TATNP", "TATN", "SNGS", "SNGSP", "BANE", "BANEP", "RNFT"],
    "–ú–µ—Ç–∞–ª–ª—ã –∏ –¥–æ–±—ã—á–∞": ["ALRS", "GMKN", "RUAL", "TRMK", "MAGN", "NLMK", "CHMF", "MTLRP", "MTLR", "VSMO", "RASP", "SELG", "PLZL", "UGLD"],
    "IT": ["YDEX", "DATA", "HEAD", "POSI", "VKCO", "ASTR", "IVAT", "DELI", "WUSH", "CNRU", "DIAS", "SOFL"],
    "–¢–µ–ª–µ–∫–æ–º": ["MTSS", "RTKMP", "RTKM", "MGTSP"],
    "–°—Ç—Ä–æ–∏—Ç–µ–ª–∏": ["ETLN", "SMLT", "LSRG", "PIKK"],
    "–†–∏—Ç–µ–π–ª": ["X5", "MGNT", "BELU", "LENT", "OZON", "EUTR", "ABRD", "GCHE", "AQUA", "HNFG", "MVID", "VSEH", "FIXP"],
    "–≠–ª–µ–∫—Ç—Ä–æ": ["IRAO", "UPRO", "LSNGP", "MSRS", "MRKZ", "MRKU", "MRKC", "MRKP", "FEES", "HYDR", "DVEC", "TGKA", "TGKN", "TGKB", "MSNG", "ELFV"],
    "–¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç –∏ –ª–æ–≥–∏—Å—Ç–∏–∫–∞": ["TRNFP", "AFLT", "FESH", "NMTP", "FLOT"],
    "–ê–≥—Ä–æ": ["PHOR", "RAGR", "KZOS", "NKNC", "UFOSP", "KAZT", "AKRN", "NKHP"],
    "–ú–µ–¥–∏—Ü–∏–Ω–∞": ["MDMG", "OZPH", "PRMD", "GECO", "APTK", "LIFE", "ABIO", "GEMC"],
    "–ú–∞—à–∏–Ω–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ": ["UWGN", "SVAV", "KMAZ", "UNAC", "IRKT", "ZILLP"]
}

TICKERS_PER_PAGE = 10

# === –ù–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞: long_moneyflow ===
def calculate_money_ad(df):
    df = df.copy()
    df['TYP'] = (df['high'] + df['low'] + df['close']) / 3
    df['CLV'] = ((df['close'] - df['low']) - (df['high'] - df['close'])) / (df['high'] - df['low'])
    df['CLV'] = df['CLV'].fillna(0)
    df['money_flow'] = df['CLV'] * df['volume'] * df['TYP']
    df['money_ad'] = df['money_flow'].cumsum()
    return df

async def long_moneyflow(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üîç –ò—â—É –¢–æ–ø –ø–æ —Ä–æ—Å—Ç—É –¥–µ–Ω–µ–∂–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ (Money A/D)...")
    result = []
    for ticker in sum(SECTORS.values(), []):
        try:
            df = get_moex_data(ticker, days=30)
            if df.empty or len(df) < 15:
                continue

            df = df.rename(columns={'CLOSE': 'close', 'VOLUME': 'volume'})  # –µ—Å–ª–∏ –µ—â–µ –Ω–µ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–æ
            df = calculate_money_ad(df)

            ad_start = df['money_ad'].iloc[-10]
            ad_end = df['money_ad'].iloc[-1]
            ad_delta = ad_end - ad_start

            price_start = df['close'].iloc[-10]
            price_end = df['close'].iloc[-1]
            date_start = df.index[-10].strftime('%d.%m.%y')
            date_end = df.index[-1].strftime('%d.%m.%y')

            price_delta = price_end - price_start
            price_pct = 100 * price_delta / price_start

            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            print(f"{ticker} ‚Äî moneyAD start: {ad_start:.2f}, end: {ad_end:.2f}, Œî: {ad_delta:.2f}, price %: {price_pct:.2f}")

            if ad_delta > 0 or ad_delta < 0 :
                result.append((ticker, round(price_pct, 2), round(ad_delta, 2), date_start, date_end))
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ Money A/D –¥–ª—è {ticker}: {e}")
            continue

    if not result:
        await update.message.reply_text("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∞–∫—Ç–∏–≤–æ–≤ —Å —Ä–æ—Å—Ç–æ–º –¥–µ–Ω–µ–∂–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ (Money A/D)")
        return

    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–µ–ª—å—Ç–µ –¥–µ–Ω–µ–∂–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ (—Ä—É–±–ª–∏)
    result.sort(key=lambda x: x[2], reverse=True)
    result = result[:10]  # —Ç–æ–ø-10

    msg = "üè¶ –¢–æ–ø –ø–æ —Ä–æ—Å—Ç—É –¥–µ–Ω–µ–∂–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ (Money A/D –∑–∞ 2 –Ω–µ–¥–µ–ª–∏):\n\n"
    for ticker, price_pct, ad_delta, date_start, date_end in result:
        msg += (f"{ticker}: –¶–µ–Ω–∞ {price_pct:.2f}%, –î–µ–Ω–µ–∂–Ω—ã–π –ø–æ—Ç–æ–∫ {ad_delta/1000000:.2f} –ú–ª–Ω ‚ÇΩ "
                f"(–î–∞—Ç–∞ –æ—Ç—Å—á–µ—Ç–∞ {date_start}, –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞ {date_end})\n")

    await update.message.reply_text(msg)

# –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –®—Ç–µ–π–Ω
def get_moex_weekly_data(ticker="SBER", weeks=100):
    try:
        till = datetime.today().strftime('%Y-%m-%d')
        from_date = (datetime.today() - pd.Timedelta(weeks=weeks * 1.5)).strftime('%Y-%m-%d')
        url = f"https://iss.moex.com/iss/engines/stock/markets/shares/securities/{ticker}/candles.json?interval=7&from={from_date}&till={till}"
        r = requests.get(url, timeout=10)
        r.raise_for_status()
        data = r.json()
        candles = data['candles']['data']
        columns = data['candles']['columns']
        df = pd.DataFrame(candles, columns=columns)
        df['begin'] = pd.to_datetime(df['begin'])
        df = df.sort_values('begin')
        df.set_index('begin', inplace=True)
        df = df.rename(columns={'close': 'CLOSE'})
        df = df[['CLOSE']].dropna()
        return df.tail(weeks)
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {ticker}: {e}")
        return pd.DataFrame()

#–ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–∞ —à—Ç–µ–π–Ω
def plot_stan_chart(df, ticker):
    if df.empty:
        return None
    
    try:
        df['SMA30'] = df['CLOSE'].rolling(window=30).mean()
        df['Upper'] = df['SMA30'] + 2 * df['CLOSE'].rolling(window=30).std()
        df['Lower'] = df['SMA30'] - 2 * df['CLOSE'].rolling(window=30).std()

        plt.figure(figsize=(12, 6))
        plt.plot(df.index, df['CLOSE'], label='–¶–µ–Ω–∞', color='blue')
        plt.plot(df.index, df['SMA30'], label='SMA 30', linewidth=2.5, color='black')
        plt.plot(df.index, df['Upper'], label='BB –≤–µ—Ä—Ö', linestyle='--', color='gray')
        plt.plot(df.index, df['Lower'], label='BB –Ω–∏–∑', linestyle='--', color='gray')

        plt.title(f"–í–∞–π–Ω—à—Ç–µ–π–Ω: {ticker} –Ω–∞ 1W –¢–§")
        plt.legend()
        plt.grid(True)
        plt.tight_layout()
        filename = f"{ticker}_stan.png"
        plt.savefig(filename)
        plt.close()
        return filename
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è {ticker}: {e}")
        plt.close()
        return None

# –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å MOEX
def get_moex_data(ticker="SBER", days=100):
    try:
        till = datetime.today().strftime('%Y-%m-%d')
        from_date = (datetime.today() - pd.Timedelta(days=days * 1.5)).strftime('%Y-%m-%d')
        url = f"https://iss.moex.com/iss/engines/stock/markets/shares/securities/{ticker}/candles.json?interval=24&from={from_date}&till={till}"
        r = requests.get(url, timeout=10)
        r.raise_for_status()
        data = r.json()
        candles = data['candles']['data']
        columns = data['candles']['columns']
        df = pd.DataFrame(candles, columns=columns)
        df['begin'] = pd.to_datetime(df['begin'])
        df = df.sort_values('begin')  # —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–∞—Ç–µ
        df.set_index('begin', inplace=True)
        df = df.rename(columns={'close': 'CLOSE', 'volume': 'VOLUME'})
        df = df[['CLOSE', 'VOLUME']].dropna()
        return df.tail(days)
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {ticker}: {e}")
        return pd.DataFrame()

# –í—ã—á–∏—Å–ª–µ–Ω–∏–µ RSI –≤—Ä—É—á–Ω—É—é
def compute_rsi(series, window=14):
    if len(series) < window:
        return pd.Series([np.nan] * len(series), index=series.index)
    delta = series.diff()
    gain = np.where(delta > 0, delta, 0)
    loss = np.where(delta < 0, -delta, 0)
    avg_gain = pd.Series(gain, index=series.index).rolling(window=window).mean()
    avg_loss = pd.Series(loss, index=series.index).rolling(window=window).mean()
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi.round(0)

# RSI –∏ –∞–Ω–æ–º–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–º—ã
def analyze_indicators(df):
    if df.empty:
        return df
    
    df['RSI'] = compute_rsi(df['CLOSE'], window=14)
    df['Volume_Mean'] = df['VOLUME'].rolling(window=10).mean()
    df['Anomaly'] = df['VOLUME'] > 1.5 * df['Volume_Mean']
    df['Volume_Multiplier'] = df['VOLUME'] / df['Volume_Mean']
    df['EMA9'] = df['CLOSE'].ewm(span=9, adjust=False).mean()
    df['EMA20'] = df['CLOSE'].ewm(span=20, adjust=False).mean()
    df['EMA50'] = df['CLOSE'].ewm(span=50, adjust=False).mean()
    df['EMA100'] = df['CLOSE'].ewm(span=100, adjust=False).mean()
    df['EMA200'] = df['CLOSE'].ewm(span=200, adjust=False).mean()
    return df

# –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ
def find_levels(df):
    if df.empty:
        return []
    
    levels = []
    closes = df['CLOSE'].values
    local_max = argrelextrema(closes, np.greater)[0]
    local_min = argrelextrema(closes, np.less)[0]

    extrema = sorted([(i, closes[i]) for i in np.concatenate((local_max, local_min))], key=lambda x: x[1])
    if len(extrema) > 0:
        grouped = pd.Series([round(p[1], 1) for p in extrema]).value_counts()
        strong_levels = grouped[grouped > 1].index.tolist()
        for level in strong_levels:
            for i, val in extrema:
                if abs(val - level) < 0.5:
                    levels.append((df.index[i], val))
                    break
    return levels

# –î–≤–æ–π–Ω–∞—è –≤–µ—Ä—à–∏–Ω–∞ –∏ –¥–Ω–æ
def detect_double_patterns(df):
    if df.empty or len(df) < 5:
        return []
    
    closes = df['CLOSE'].values
    patterns = []
    for i in range(2, len(closes) - 2):
        if closes[i-2] < closes[i-1] < closes[i] and closes[i] > closes[i+1] > closes[i+2]:
            patterns.append(('Double Top', df.index[i], closes[i]))
        if closes[i-2] > closes[i-1] > closes[i] and closes[i] < closes[i+1] < closes[i+2]:
            patterns.append(('Double Bottom', df.index[i], closes[i]))
    return patterns

# –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–∞
def plot_stock(df, ticker, levels=[], patterns=[]):
    if df.empty:
        return None
    
    try:
        plt.figure(figsize=(12, 6))
        plt.plot(df.index, df['CLOSE'], label='–¶–µ–Ω–∞')

        plt.plot(df.index, df['EMA9'], label='EMA9', linestyle='--', alpha=0.7)
        plt.plot(df.index, df['EMA20'], label='EMA20', linestyle='--', alpha=0.7)
        plt.plot(df.index, df['EMA50'], label='EMA50', linestyle='--', alpha=0.7)
        plt.plot(df.index, df['EMA100'], label='EMA100', linestyle='--', alpha=0.7)
        plt.plot(df.index, df['EMA200'], label='EMA200', linestyle='--', alpha=0.7)

        # –ê–Ω–æ–º–∞–ª—å–Ω—ã–µ –æ–±—ä–µ–º—ã
        for idx in df[df['Anomaly']].index:
            volume_ratio = df.loc[idx, 'Volume_Multiplier']
            plt.scatter(idx, df.loc[idx, 'CLOSE'], color='red')
            plt.text(idx, df.loc[idx, 'CLOSE'], f"{volume_ratio:.1f}x", color='red', fontsize=8, ha='left')

        # –£—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
        for date, price in levels:
            plt.axhline(price, linestyle='--', alpha=0.3)

        # –ü–∞—Ç—Ç–µ—Ä–Ω—ã
        plotted_top = False
        plotted_bottom = False
        for name, date, price in patterns:
            if name == 'Double Top':
                marker = '^'
                color = 'red'
                label = 'Double Top' if not plotted_top else None
                plotted_top = True
            else:
                marker = 'v'
                color = 'green'
                label = 'Double Bottom' if not plotted_bottom else None
                plotted_bottom = True
            plt.scatter(date, price, label=label, s=100, marker=marker, color=color)

        plt.title(f"{ticker}: –ì—Ä–∞—Ñ–∏–∫ —Å –∞–Ω–∞–ª–∏–∑–æ–º")
        plt.legend()
        plt.grid(True)
        plt.tight_layout()
        filename = f"{ticker}_analysis.png"
        plt.savefig(filename)
        plt.close()
        return filename
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è {ticker}: {e}")
        plt.close()
        return None

# Telegram –∫–æ–º–∞–Ω–¥—ã
if Update and ContextTypes:
    async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
        text = (
            "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –±–æ—Ç –æ—Ç –∫–æ–º–∞–Ω–¥—ã @TradeAnsh –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∞–∫—Ü–∏–π –ú–æ—Å–±–∏—Ä–∂–∏.\n"
            "–ö–æ–º–∞–Ω–¥—ã:\n"
            "/a ‚Äî –≤—ã–±—Ä–∞—Ç—å –∞–∫—Ü–∏—é —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫–∏\n"
            "/all ‚Äî –∞–Ω–∞–ª–∏–∑ –≥–æ–ª—É–±—ã—Ö —Ñ–∏—à–µ–∫ –ú–æ—Å–±–∏—Ä–∂–∏\n"
            "/stan ‚Äî –∞–Ω–∞–ª–∏–∑ –∞–∫—Ü–∏–∏ –ø–æ –º–µ—Ç–æ–¥—É –°—Ç—ç–Ω–∞ –í–∞–π–Ω—à—Ç–µ–π–Ω–∞\n"
            "/stan_recent ‚Äî –∞–∫—Ü–∏–∏ —Å –Ω–µ–¥–∞–≤–Ω–∏–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ–º SMA30 —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö\n"
            "/long_moneyflow - –¢–æ–ø –ø–æ —Ä–æ—Å—Ç—É –¥–µ–Ω–µ–∂–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞ (Money A/D) –∑–∞ 2 –Ω–µ–¥–µ–ª–∏\n"
        )
        await update.message.reply_text(text)

    async def a(update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [[InlineKeyboardButton(sector, callback_data=f"sector:{sector}:0")] for sector in SECTORS]
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ç—Ä–∞—Å–ª—å:", reply_markup=InlineKeyboardMarkup(keyboard))

    async def stan(update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [[InlineKeyboardButton(sector, callback_data=f"stan_sector:{sector}:0")] for sector in SECTORS]
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ç—Ä–∞—Å–ª—å –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø–æ –®—Ç–µ–π–Ω—É:", reply_markup=InlineKeyboardMarkup(keyboard))

    async def all(update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text("–ù–∞—á–∏–Ω–∞—é –∞–Ω–∞–ª–∏–∑ –≤—Å–µ—Ö –∞–∫—Ü–∏–π. –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è...")
        
        for ticker in sum(SECTORS.values(), []):
            try:
                df = get_moex_data(ticker)
                if df.empty:
                    await update.message.reply_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è {ticker}")
                    continue
                    
                df = analyze_indicators(df)
                levels = find_levels(df)
                patterns = detect_double_patterns(df)
                chart = plot_stock(df, ticker, levels, patterns)
                
                if chart is None:
                    await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≥—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è {ticker}")
                    continue
                
                rsi_series = df['RSI'].dropna()
                rsi_value = rsi_series.iloc[-1] if not rsi_series.empty else "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è RSI"
                latest_date = df.index.max().strftime('%Y-%m-%d')
                text_summary = f"\n–ü–æ—Å–ª–µ–¥–Ω–∏–π RSI: {rsi_value}\n–ê–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö: –¥–æ {latest_date}\n"
                
                with open(chart, 'rb') as photo:
                    await update.message.reply_photo(photo=photo)
                await update.message.reply_text(f"{ticker}\n{text_summary}")
                
                # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
                if os.path.exists(chart):
                    os.remove(chart)
                    
            except Exception as e:
                await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ {ticker}: {str(e)}")

    def find_sma30_crossover(ticker, days=7):
        """
        –ù–∞—Ö–æ–¥–∏—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Ü–µ–Ω—ã —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö —á–µ—Ä–µ–∑ SMA30 –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¥–Ω–∏
        –ò –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –Ω–∞ —Ç–µ–∫—É—â–∏–π –º–æ–º–µ–Ω—Ç —Ü–µ–Ω–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤—ã—à–µ SMA30
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞—Ç—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –∏–ª–∏ None
        """
        try:
            df = get_moex_data(ticker, days=60)  # –ë–µ—Ä—ë–º –±–æ–ª—å—à–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ SMA30
            if df.empty or len(df) < 35:  # –ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º 35 –¥–Ω–µ–π –¥–ª—è SMA30 + –ø—Ä–æ–≤–µ—Ä–∫–∞
                return None
            
            # –í—ã—á–∏—Å–ª—è–µ–º SMA30
            df['SMA30'] = df['CLOSE'].rolling(window=30).mean()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ –≤—ã—à–µ SMA30
            current_close = df['CLOSE'].iloc[-1]
            current_sma30 = df['SMA30'].iloc[-1]
            
            if current_close <= current_sma30:
                return None  # –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ –Ω–µ –≤—ã—à–µ SMA30
            
            # –ë–µ—Ä—ë–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ days –¥–Ω–µ–π –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
            recent_df = df.tail(days + 1)  # +1 –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º –¥–Ω—ë–º
            
            crossover_date = None
            
            # –ò—â–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
            for i in range(1, len(recent_df)):
                prev_close = recent_df['CLOSE'].iloc[i-1]
                curr_close = recent_df['CLOSE'].iloc[i]
                prev_sma = recent_df['SMA30'].iloc[i-1]
                curr_sma = recent_df['SMA30'].iloc[i]
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ: –≤—á–µ—Ä–∞ —Ü–µ–Ω–∞ –±—ã–ª–∞ –Ω–∏–∂–µ SMA30, —Å–µ–≥–æ–¥–Ω—è –≤—ã—à–µ
                if (prev_close < prev_sma and curr_close > curr_sma):
                    crossover_date = recent_df.index[i]
                    break
            
            return crossover_date
            
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è SMA30 –¥–ª—è {ticker}: {e}")
            return None  
            
    async def stan_recent(update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text("üîç –ò—â—É –∞–∫—Ü–∏–∏ —Å –Ω–µ–¥–∞–≤–Ω–∏–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ–º —Ü–µ–Ω—ã —á–µ—Ä–µ–∑ SMA30 —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö...")
        
        crossovers = []
        all_tickers = sum(SECTORS.values(), [])
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π —Ç–∏–∫–µ—Ä
        for ticker in all_tickers:
            try:
                crossover_date = find_sma30_crossover(ticker, days=7)
                if crossover_date:
                    crossovers.append((ticker, crossover_date))
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ {ticker}: {e}")
                continue
        
        if not crossovers:
            await update.message.reply_text("üìä –ó–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∞–∫—Ü–∏–π —Å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ–º —Ü–µ–Ω—ã —á–µ—Ä–µ–∑ SMA30 —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö.")
            return
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ (–æ—Ç —Å–∞–º–æ–≥–æ —Å–≤–µ–∂–µ–≥–æ –∫ —Å–∞–º–æ–º—É —Å—Ç–∞—Ä–æ–º—É)
        crossovers.sort(key=lambda x: x[1], reverse=True)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        result_text = "üìà –ê–∫—Ü–∏–∏ —Å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ–º —Ü–µ–Ω—ã —á–µ—Ä–µ–∑ SMA30 —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π:\n\n"
        
        for ticker, date in crossovers:
            formatted_date = date.strftime('%d.%m.%Y')
            result_text += f"{ticker} {formatted_date}\n"
        
        result_text += f"\nüî¢ –í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ: {len(crossovers)} –∞–∫—Ü–∏–π"
        
        await update.message.reply_text(result_text)

    async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        data = query.data

        try:
            # === –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—ã—á–Ω–æ–π –∫–æ–º–∞–Ω–¥—ã /a ===
            if data == "back_to_sectors":
                keyboard = [[InlineKeyboardButton(sector, callback_data=f"sector:{sector}:0")] for sector in SECTORS]
                await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ç—Ä–∞—Å–ª—å:", reply_markup=InlineKeyboardMarkup(keyboard))

            elif data.startswith("sector:"):
                _, sector, page = data.split(":")
                page = int(page)
                tickers = SECTORS.get(sector, [])
                start = page * TICKERS_PER_PAGE
                end = start + TICKERS_PER_PAGE
                visible = tickers[start:end]

                keyboard = [[InlineKeyboardButton(t, callback_data=f"ticker:{t}")] for t in visible]
                nav = []
                if start > 0:
                    nav.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"sector:{sector}:{page-1}"))
                if end < len(tickers):
                    nav.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"sector:{sector}:{page+1}"))
                if nav:
                    keyboard.append(nav)
                keyboard.append([InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –æ—Ç—Ä–∞—Å–ª—è–º", callback_data="back_to_sectors")])

                await query.edit_message_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –æ—Ç—Ä–∞—Å–ª—å: {sector}. –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä:", reply_markup=InlineKeyboardMarkup(keyboard))

            elif data.startswith("ticker:"):
                ticker = data.split(":", 1)[1]
                await query.edit_message_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ç–∏–∫–µ—Ä: {ticker}. –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∞–Ω–∞–ª–∏–∑...")

                df = get_moex_data(ticker)
                if df.empty:
                    await context.bot.send_message(chat_id=query.message.chat.id, text=f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è {ticker}")
                    return

                df = analyze_indicators(df)
                levels = find_levels(df)
                patterns = detect_double_patterns(df)
                chart = plot_stock(df, ticker, levels, patterns)
                
                if chart is None:
                    await context.bot.send_message(chat_id=query.message.chat.id, text=f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≥—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è {ticker}")
                    return

                rsi_series = df['RSI'].dropna()
                rsi_value = rsi_series.iloc[-1] if not rsi_series.empty else "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è RSI"
                latest_date = df.index.max().strftime('%Y-%m-%d')

                text_summary = f"\n–ü–æ—Å–ª–µ–¥–Ω–∏–π RSI: {rsi_value}\n"
                text_summary += f"–ê–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö: –¥–æ {latest_date}\n"

                with open(chart, 'rb') as photo:
                    await context.bot.send_photo(chat_id=query.message.chat.id, photo=photo)
                await context.bot.send_message(chat_id=query.message.chat.id, text=text_summary)
                
                # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
                if os.path.exists(chart):
                    os.remove(chart)

            # === –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /stan ===
            elif data.startswith("stan_sector:"):
                _, sector, page = data.split(":")
                page = int(page)
                tickers = SECTORS.get(sector, [])
                start = page * TICKERS_PER_PAGE
                end = start + TICKERS_PER_PAGE
                visible = tickers[start:end]

                keyboard = [[InlineKeyboardButton(t, callback_data=f"stan_ticker:{t}")] for t in visible]
                nav = []
                if start > 0:
                    nav.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"stan_sector:{sector}:{page-1}"))
                if end < len(tickers):
                    nav.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"stan_sector:{sector}:{page+1}"))
                if nav:
                    keyboard.append(nav)
                keyboard.append([InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –æ—Ç—Ä–∞—Å–ª—è–º", callback_data="stan_back")])

                await query.edit_message_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ –æ—Ç—Ä–∞—Å–ª—å: {sector}. –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–∫–µ—Ä:", reply_markup=InlineKeyboardMarkup(keyboard))

            elif data == "stan_back":
                keyboard = [[InlineKeyboardButton(sector, callback_data=f"stan_sector:{sector}:0")] for sector in SECTORS]
                await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ç—Ä–∞—Å–ª—å –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø–æ –®—Ç–µ–π–Ω—É:", reply_markup=InlineKeyboardMarkup(keyboard))

            elif data.startswith("stan_ticker:"):
                ticker = data.split(":", 1)[1]
                await query.edit_message_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ç–∏–∫–µ—Ä: {ticker}. –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∞–Ω–∞–ª–∏–∑ –ø–æ –®—Ç–µ–π–Ω—É...")

                df = get_moex_weekly_data(ticker)
                if df.empty:
                    await context.bot.send_message(chat_id=query.message.chat.id, text=f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è {ticker}")
                    return

                chart = plot_stan_chart(df, ticker)
                if chart is None:
                    await context.bot.send_message(chat_id=query.message.chat.id, text=f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≥—Ä–∞—Ñ–∏–∫–∞ –¥–ª—è {ticker}")
                    return

                latest_date = df.index.max().strftime('%Y-%m-%d')
                with open(chart, 'rb') as photo:
                    await context.bot.send_photo(chat_id=query.message.chat.id, photo=photo)
                await context.bot.send_message(chat_id=query.message.chat.id, text=f"–ì—Ä–∞—Ñ–∏–∫ –ø–æ—Å—Ç—Ä–æ–µ–Ω –ø–æ –¥–∞–Ω–Ω—ã–º –Ω–∞ {latest_date}")
                
                # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –ø–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏
                if os.path.exists(chart):
                    os.remove(chart)

        except Exception as e:
            await context.bot.send_message(chat_id=query.message.chat.id, text=f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {str(e)}")

# ==== Flask —Å–µ—Ä–≤–µ—Ä –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Ä–∞–±–æ—Ç—ã 24/7 ====
from flask import Flask
from threading import Thread

app_web = Flask('')

@app_web.route('/')
def home():
    return "–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç!"

def run():
    app_web.run(host='0.0.0.0', port=8080)

def keep_alive():
    t = Thread(target=run)
    t.start()

# ==== –ó–∞–ø—É—Å–∫ Telegram-–±–æ—Ç–∞ —Å –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–æ–º ====
if ApplicationBuilder:
    TOKEN = os.getenv("TELEGRAM_TOKEN")
    if TOKEN is None:
        print("–û—à–∏–±–∫–∞: –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è TELEGRAM_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.")
    else:
        keep_alive()  # ‚Üê –∑–∞–ø—É—Å–∫ Flask
        app = ApplicationBuilder().token(TOKEN).build()
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CommandHandler("a", a))
        app.add_handler(CommandHandler("all", all))  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é all
        app.add_handler(CommandHandler("stan", stan))
        app.add_handler(CommandHandler("stan_recent", stan_recent))
        app.add_handler(CommandHandler("long_moneyflow", long_moneyflow))
        app.add_handler(CallbackQueryHandler(handle_callback))
        print("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è Flask-—Å–µ—Ä–≤–µ—Ä–æ–º.")
        app.run_polling()
else:
    print("–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å Telegram-–±–æ—Ç–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ 'telegram'.")
